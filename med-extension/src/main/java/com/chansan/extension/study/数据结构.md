# 数据结构定义

#### 逻辑结构

1. 集合结构
2. 线型结构
3. 树形结构
4. 图形结构

#### 物理结构

1. 顺序存储结构
2. 链接存储结构

#### 抽象数据类型

## 算法

> 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

### 算法的特性

1. 输入、输出
    1. 具有0个或者过个输入，一点有输出。不输出结果，要算法何用
2. 有穷性
    1. 算法在执行有限的步骤之后，自动结束而不会出现无限循环
    2. 具有在实际应用当中合理的、可以接受的“边界”
3. 确定性
    1. 算法的每一步骤都具有确定的含义，不会出现二义性
    2. 算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义。
4. 可行性
    1. 算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。可行性意味着算法可以转换为程序上机运行，并得到正确的结果。

### 算法设计要求

1. 正确性 (应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案 )
    1. 算法程序没有语法错误。
    2. 算法程序对于合法的输入数据能够产生满足要求的输出结果。
    3. 算法程序对于非法的输入数据能够得出满足规格说明的结果。
    4. 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果
2. 可读性：
    1. 算法设计的另一目的是为了便于阅读、理解和交流,可读性高有助于人们理解算法，晦涩难懂的算法往往隐含错误，不易被发现，并且难于调试和修改
3. 健壮性
    1. 一个好的算法还应该能对输入数据不合法的情况做合适的处理
4. 时间效率高和存储量低
    1. 时间效率指的是算法的执行时间，对于同一个问题，如果有多个算法能够解决， 执行时间短的算法效率高，执行时间长的效率低。
    2. 存储量需求指的是算法在执行过程中需要的最大存储空间， 主要指算法程序运行时所占用的内存或外部硬盘存储空间。
    3. 设计算法应该尽量满足时间效率高和存储量低的需求。

### 算法效率度量

1. 事后统计方法
    1. 这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低
    2. 受各种实际因数影响，不够科学 
2. 事前分析法
    1. 算法采用的策略、方法。
    2. 编译产生的代码质量。
    3. 问题的输入规模。
    4. 机器执行指令的速度。
    5. 抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间，依赖于算法的好坏和问题的输入规模。(
       输入规模是指输入量的多少)

### 函数的渐近增长

给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。
从中我们发现，随着n的增大，后面的+3还是+1其实是不影响最终的算法变化的，例如算法A′与算法B′，所以，我们可以忽略这些加法常数。

| 次数       | 2n^2    | 3n+1   | 2n^2 + 3n +1 |
|----------|---------|--------|--------------|
| n=1      | 2       | 4      | 6            |
| n=5      | 50      | 16     | 66           |
| n=10     | 200     | 31     | 231          |
| n=100    | 2000    | 301    | 2301         |
| n=1000   | 20000   | 3001   | 23001        |
| n=10000  | 200000  | 30001  | 230001       |
| n=100000 | 2000000 | 300001 | 2300001      |

### 时间复杂度

> 在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。  
> 算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)
> 的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。  
> 其中f(n)是问题规模n的某个函数。  
> 这样用大写O( )来体现算法时间复杂度的记法，我们称之为大O记法。  
> 一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。  
> 显然，由此算法时间复杂度的定义可知，我们的三个求和算法的时间复杂度分别 O(1)常数阶、O(n)线性阶、O(n2)平方阶

#### 推导大O阶 (可能需要补数学了)
> 用常数1取代运行时间中的所有加法常数。  
> 在修改后的运行次数函数中，只保留最高阶项。  
> 如果最高阶项存在且不是1，则去除与这个项相乘的常数。

#### 常见的时间复杂度

| 执行次数           | 函数阶     | 非正式术语  |
|----------------|---------|--------|
| 12             | O(1)    | 常数阶    |
| 2n+3           | O(n)    | 线性阶    |
| 3n2+2n+1O      | (n2  )  | 平方阶    |
| 5log2n+20O     | (logn)  | 对数阶    |
| 2n+3nlog2n+19O | (nlogn) | nlogn阶 |
| 6n3+2n2 +3n+4O | (n3  )  | 立方阶    |
| 2n             | O(2n  ) | 指数阶    |

> 对数  
> 在数学中，对数是对求幂的逆运算，正如除法是乘法的逆运算，反之亦然。这意味着一个数字的对数是必须产生另一个固定数字（基数）的指数。   
> 在简单的情况下，乘数中的对数计数因子。更一般来说，乘幂允许将任何正实数提高到任何实际功率，总是产生正的结果，因此可以对于b不等于1的任何两个正实数b和x计算对数。  
如果a的x次方等于N（a>0，且a≠1），那么数x叫做以a为底N的对数（logarithm），记作x=loga N。其中，a叫做对数的底数，N叫做真数。

> 常用的时间复杂度所耗费的时间从小到大依次是：  
> O(1)<O(logn)<O(n)<O(nlogn)<O(n2)<O(n3)<O(2n)<O(n!)<O(nn)

### 最坏和平均
对算法的分析  
一种方法是计算所有情况的平均值， 这种时间复杂度的计算方法称为平均时间复杂度。  
另一种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂度。  
**一般在没有特殊说明的情况下，都是指最坏时间复杂度**


### 空间复杂度
> 算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。

## 数据结构

### 线型表

#### 顺序存储
* 采用联系的存储单元依次存储元素
* 读取 O(1) (顺序读取)
* 插入需要移动元素 O(n) 
* 需要需分配空间，容易造成资源浪费/溢出

#### 链式存储
* 采用链式存储结构,可用任意一组存储单元存放元素
* 读取 O(n)  (需要找头节点)
* 可直接插入到指定位置 O(1)
* 只要有足够的空间便可以分配,不受存储空间/个数限制

#### 静态链表
* 采用下标和游标,下标代表当前节点位置，游标记录下一节点位置
* 下标0的游标记录第一个空闲空间的下标
* 下标最后一位的游标记录第一个可用元素的下标
* 插入修改只需要修改游标
* 失去了顺序存储结构随机存储的特性

#### 循环链表
* 单链表的基础上,链接了头尾
* 采用尾指针表示循环列表
   * 尾指针 lastIndex 复杂度 O(1), 头指针 lastIndex.next  复杂度 O(1)

> 如果还是用头指针表示循环列表呢  
> 头指针 index 复杂度 O(1)  
> 尾指针 遍历index到结尾indexN 复杂度O(N)

#### 双向链表
* 解决链表next指针的特性，导致遍历单向性问题
* 采用双指针记录前后节点，代价变更时需要同时改变两个指针变量


### 栈与队列
